---
title: "Digital Ocean"
---

import SecretsSection from '/snippets/kubernetes-deploy-envs-section.mdx';
import PortSection from '/snippets/kubernetes-deploy-port-section.mdx';

It's a step-by-step Ship deployment guide. We will use Digital Ocean Managed [Kubernetes](https://www.digitalocean.com/products/kubernetes), [Container Registry](https://www.digitalocean.com/products/container-registry), [Mongo Atlas](https://www.mongodb.com/), [GitHub Actions](https://github.com/features/actions) for automated deployment, and [CloudFlare](https://www.cloudflare.com/) for DNS and SSL configuration.

You need to create [GitHub](https://github.com/), [CloudFlare](https://www.cloudflare.com/), [Digital Ocean](https://www.digitalocean.com/) and [MongoDB Atlas](https://www.mongodb.com/cloud/atlas/register) accounts and install the next tools on your machine before starting:

* [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl) - CLI tool for accessing Kubernetes cluster;
* [kubectx](https://github.com/ahmetb/kubectx) - CLI tool for easier switching between Kubernetes contexts;
* [helm](https://helm.sh/docs/intro/install) - CLI tool for managing Kubernetes deployments;
* [k8sec](https://github.com/dtan4/k8sec) - CLI tool for managing Kubernetes Secrets easily;

<Accordion title="How to install k8sec on Linux?">
  Download k8sec tar.gz, then do:

  ```
  chmod +x k8sec
  ```
  ```
  sudo cp k8sec /usr/local/bin/
  ```
  ```
  k8sec --help
  ```
</Accordion>

Try the next commands to ensure that everything is installed correctly:

```
kubectl

kubectx

helm

k8sec
```

Also, you need [git](https://git-scm.com/) and [Node.js](https://nodejs.org/en/) if you already haven't.

## Setup project

First, initialize your project. Type `npx create-ship-app@latest` in the terminal then choose **Digital Ocean Managed Kubernetes** deployment type.

![Init project](/images/init-project.png)

You will have next project structure.

```shell
/deploy-guide
  /.github
  /apps
    /api
    /web
  /deploy
  ...
```

Create GitHub private repository and upload source code.

![Private repo](/images/private-repo.png)

```shell
cd my-ship-app
git remote add origin git@github.com:dzinrai/my-ship-app.git
git push -u origin main
```

## Container registry

You need to create [Container Registry](https://www.digitalocean.com/products/container-registry) for storing Docker images. The deployment script will upload images to Container Registry during the build step, and Kubernetes will automatically pull these images from Container Registry to run a new version of service during the deployment step.

Usually `deploy-guide` is the name of organization, and `my-ship-app` is the name of project.

![Container Registry creation](/images/container-registry-creation.png)

After some time, you will get registry endpoint.

![Container Registry creation](/images/container-registry-created.png)

Now you should configure the deployment script to point Container Registry.
Need to update `dockerRegistry.name` value to `registry.digitalocean.com/deploy-guide/my-ship-app`.

```javascript deploy/script/src/config.js
const config = {
  ...
  dockerRegistry: {
    name: "registry.digitalocean.com/deploy-guide/my-ship-app",
    ...
  },
};
```

`registry.digitalocean.com/deploy-guide/my-ship-app` consists of 2 values:

- `registry.digitalocean.com/deploy-guide` - registry endpoint;
- `my-ship-app` - project name;

Docker images for each service are stored in separate repository.
In Digital Ocean repositories are created automatically when something is uploaded by specific paths.
During deployment process script will automatically create paths to repositories in next format:

- [**API**](/api-reference/overview) - registry.digitalocean.com/deploy-guide/my-ship-app-api;
- [**Scheduler**](/scheduler) - registry.digitalocean.com/deploy-guide/my-ship-app-scheduler;
- [**Migrator**](/migrator) - registry.digitalocean.com/deploy-guide/my-ship-app-migrator;
- [**Web**](/web/overview) - registry.digitalocean.com/deploy-guide/my-ship-app-web;

<Tip>
  Images for all environments will be uploaded to the same repository for each
  service.
</Tip>

## Kubernetes cluster

Now let's create [Managed Kubernetes](https://www.digitalocean.com/products/kubernetes) cluster.

<Steps>
  <Step title="Select a region">
    Navigate to the cluster creation page [here](https://cloud.digitalocean.com/kubernetes/clusters/new)<br/>
    <Tip>
      We recommend you to create a cluster in the region where your end-users are located, it will reduce response time to incoming requests to all services.
    </Tip>

    <Tip>
      Also, if your cluster will be located in one region with a Container Registry deployment process will be faster. You can find more information about regions [here](https://docs.digitalocean.com/products/platform/availability-matrix/).
    </Tip>
    <Frame>
      <img src="/images/cluster-region.png" alt="Cluster Region" />
    </Frame>
  </Step>

  <Step title="Set Node pool name">
    Set Node pool name (e.g. `pool-app`) and configure Nodes.
    Digital Ocean recommends creating at least 2 nodes for the production environment. These settings will have an impact on the price of the cluster.

    <Frame>
      <img src="/images/cluster-capacity.png" alt="Cluster Capacity" />
    </Frame>
  </Step>

  <Step title="Configure cluster">
    Now you need to configure node pool in deployment script.
    Need to update `nodePool` value to `pool-app` to match the node pool name we set on the previous step.

    ```javascript deploy/script/src/config.js
    const config = {
      ...
      nodePool: "pool-app",
      dockerRegistry: {
        name: 'registry.digitalocean.com/deploy-guide/my-ship-app',
        ...
      },
    };
    ```
  </Step>

  <Step title="Set cluster name">
    Set cluster name (e.g. `my-ship-app`). A common practice is to use the project name for it.

    <Frame>
      <img src="/images/cluster-name.png" alt="Cluster Name" />
    </Frame>
  </Step>

  <Step title="Review and Create">
    Click on `Create Kubernetes Cluster` button to create a cluster.

    <Frame>
      <img src="/images/do-cluster-creation.png" alt="Cluster Creation" />
    </Frame>
  </Step>
</Steps>


## Accessing cluster from a local machine

<Steps>
  <Step title="Download cluster's kubeconfig">
    Download cluster's kubeconfig, this file includes information for accessing cluster through `kubectl`.

    <Frame>
      <img src="/images/kubeconfig-download.png" alt="Kubeconfig Download" />
    </Frame>

    ```yaml my-ship-app-kubeconfig.yaml
    apiVersion: v1
    clusters:
    - cluster:
        certificate-authority-data: ...
        server: https://...
      name: do-nyc3-my-ship-app
    contexts:
    - context:
        cluster: do-nyc3-my-ship-app
        user: do-nyc3-my-ship-app-admin
      name: do-nyc3-my-ship-app
    current-context: do-nyc3-my-ship-app
    kind: Config
    preferences: {}
    users:
    - name: do-nyc3-my-ship-app-admin
      user:
        token: dop_v1_...
    ```
  </Step>

  <Step title="Add cluster, context and user to kubeconfig">
    <Tip>
      [Kubeconfig](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/) files contain information about several clusters, you have your own on the local machine, it should have been created after `kubectl` installation.
    </Tip>

    You need to add information about the new cluster to your config.
    Find `.kube/config` file on your machine, and add `cluster`, `context` and `user` values from the downloaded config to it.

    ```yaml ~/.kube/config
    apiVersion: v1
    clusters:
    - cluster:
        certificate-authority-data: ...
        server: https://...
      name: some-cluster
    # your new cluster from my-ship-app-kubeconfig.yaml goes here
    - cluster:
        certificate-authority-data: ...
        server: https://...
      name: do-nyc3-my-ship-app
    contexts:
    - context:
        cluster: some-cluster
        user: some-user
      name: some-cluster
    # your new context from my-ship-app-kubeconfig.yaml goes here
    - context:
        cluster: do-nyc3-my-ship-app
        user: do-nyc3-my-ship-app-admin
      name: do-nyc3-my-ship-app
    current-context: some-cluster
    kind: Config
    preferences: {}
    users:
    - name: some-user
      user:
        token: dop_v1_...
    # your new user from my-ship-app-kubeconfig.yaml goes here
    - name: do-nyc3-my-ship-app-admin
      user:
        token: dop_v1_...
    ```
  </Step>

  <Step title="Switch to cluster context">
    Execute kubectx in your terminal and select your cluster from the list.
    ```shell
    kubectx
    ```

    You will see the list of available clusters.

    ```shell
    some-cluster
    do-nyc3-my-ship-app
    ```

    Select your cluster from the list:
    ```shell
    kubectx do-nyc3-my-ship-app
    ```
  </Step>

  <Step title="Verify cluster access">
    Check the installed pods by running:

    ```shell
    kubectl get pods -A
    ```

    You should see a list of system pods in your cluster:

    ```shell
    NAMESPACE     NAME                            READY   STATUS    RESTARTS   AGE
    kube-system   cilium-tb8td                    1/1     Running   0          18m
    kube-system   cilium-x5w8n                    1/1     Running   0          19m
    kube-system   coredns-5679ffb5c8-b7dzj        1/1     Running   0          17m
    kube-system   coredns-5679ffb5c8-d465r        1/1     Running   0          17m
    kube-system   cpc-bridge-proxy-ebpf-2gzfr     1/1     Running   0          17m
    kube-system   cpc-bridge-proxy-ebpf-jknzh     1/1     Running   0          17m
    kube-system   csi-do-node-jcqd2               2/2     Running   0          17m
    kube-system   csi-do-node-rpx6q               2/2     Running   0          17m
    kube-system   do-node-agent-ldhxq             1/1     Running   0          17m
    kube-system   do-node-agent-pdksz             1/1     Running   0          17m
    kube-system   hubble-relay-66f54dcd57-l7xjb   1/1     Running   0          21m
    kube-system   hubble-ui-785bdbc45b-6xd57      2/2     Running   0          18m
    kube-system   konnectivity-agent-h79mt        1/1     Running   0          17m
    kube-system   konnectivity-agent-hvv67        1/1     Running   0          17m
    ```
  </Step>
</Steps>

## Personal access token

To upload docker images in Container Registry and pull them after from cluster we need Digital Ocean [Personal Access Token](https://cloud.digitalocean.com/account/api/tokens).
When you created cluster - one with **Read Only** scope was automatically created.

But we need to [generate](https://cloud.digitalocean.com/account/api/tokens/new) a new one with:

- Name (e.g. `my-ship-app-admin-deploy`)
- **Full Access** scope
- No expiration

<Tip>
  You cannot change scope of already generated token.
</Tip>


![Digital Ocean Token](/images/do-token.png)

Now new token can be added to your local kubeconfig's `users`.

```yaml {4}
users:
  - name: do-nyc3-my-ship-app-admin
    user:
      token: dop_v1_... # paste new full access token here
```

<Warning>
  Be very careful with Personal Access Token, if someone steals it he will get access
  to all resources from your Digital Ocean account.
</Warning>

## Ingress NGINX Controller

[ingress-nginx](https://github.com/kubernetes/ingress-nginx) is an Ingress controller for Kubernetes using [NGINX](https://nginx.org) as a reverse proxy and load balancer.

<Tip>
  Learn more about ingress-nginx functionality in the **[official documentation](https://docs.nginx.com/nginx-ingress-controller/intro/how-nginx-ingress-controller-works/)**.
</Tip>

<Steps>
  <Step title="Navigate to dependencies directory">
    Change to the `deploy/dependencies` directory in your terminal.
  </Step>

  <Step title="Configure Helm Values (Optional)">

    This step is required **only if** you specified a custom node pool name in your Digital Ocean Kubernetes cluster.

    If you did, update the `doks.digitalocean.com/node-pool` value in `values.yaml.gotmpl`:

    ```yaml deploy/dependencies/ingress-nginx/values.yaml.gotmpl {5}
    controller:
      publishService:
        enabled: true
      nodeSelector:
        doks.digitalocean.com/node-pool: pool-app

    rbac:
      create: true

    defaultBackend:
      enabled: false
    ```
  </Step>


  <Step title="Install dependencies">
    Install helm dependencies using helmfile:

    ```bash
    helmfile deps
    ```
  </Step>

  <Step title="Review and apply changes">
    Preview the changes first:

    ```bash
    helmfile diff
    ```

    If the preview looks correct, apply the configuration:

    ```bash
    helmfile apply
    ```
  </Step>
</Steps>

## DNS and SSL

Once you deploy ingress-nginx, it will create a Load Balancer with external IP. All incoming requests to services should be sent to Load Balancer external IP, then requests to our services will be routed to domains from Ingresses configuration by **ingress-nginx**.

To get Load Balancer IP type `kubectl get services -n ingress-nginx` in the terminal and copy `EXTERNAL-IP` of `ingress-nginx-controller`.

```shell
oigen@MacBook-Pro-4 ~ % kubectl get services -n ingress-nginx
NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE
ingress-nginx-controller             LoadBalancer   10.245.201.160   138.68.124.241   80:30186/TCP,443:32656/TCP   28m
```

<Tip>
  It take some time while **ingress-nginx** will configure everything and
  provide `EXTERNAL-IP`.
</Tip>

We are using CloudFlare for setting DNS records. You can [register](https://developers.cloudflare.com/registrar/get-started/register-domain/) a domain in CloudFlare or [transfer](https://developers.cloudflare.com/registrar/get-started/transfer-domain-to-cloudflare/) it from another service.

Open the **DNS** tab in CloudFlare and create two `A` records for **Web** and **API** that points Load Balancer external IP.

![CloudFlare Web](/images/cloudflare-web.png)

![CloudFlare API](/images/cloudflare-api.png)

Select the **Proxied** option that will proxy all traffic through Cloudflare.
It does a lot of awesome work, you can read more about it [here](https://developers.cloudflare.com/dns/manage-dns-records/reference/proxied-dns-records/).
In our case we use it for automatic **SSL** certificates generation.

<Tip>
  If you are deploying on a staging/demo environment add the corresponding
  postfix in the domain. **Example**: ```my-app-staging```
</Tip>

Now add your domains in helm templates. In example, we are deploying on **production** environment, if you are deploying on **staging** you will need to update `staging.yaml` file.

```yaml deploy/app/api/production.yaml
service: api
port: 3001
domain: my-app-api.paralect.net
```

```yaml deploy/app/web/production.yaml
service: web
port: 3002
domain: my-app.paralect.net
```

## Database

Now, let's create [Managed MongoDB](https://www.digitalocean.com/products/managed-databases-mongodb) cluster. Select the latest MongoDB version and choose the same region as the Kubernetes cluster, it will increase database requests speed.

![MongoDB Region](/images/mongodb-region.png)

Choose a database configuration.

![MongoDB Configuration](/images/mongodb-configuration.png)

The last step is to set a cluster name. A common practice is to use the project name for it. Also, you can add an environment prefix if you have separate clusters for each environment: `my-app-staging`, `my-app-production`.

![MongoDB Name](/images/mongodb-name.png)

After some time database cluster will be created. Copy connection string and add it in **API** config.

![MongoDB Connection String](/images/mongodb-connection-string.png)

<Warning>
  Change database name from `admin` to `api-production` or `api-staging` in
  connection string.
</Warning>

MongoDB cluster is open to all incoming connections by default, which is not secure. We need to select sources that will be allowed to connect to the database. Open the **Settings** tab, and select your k8s cluster. If you want to connect to the database from your machine also add your IP to **Trusted Sources**.

![Trusted sources](/images/mongodb-trusted-sources.png)

<SecretsSection/>

<PortSection/>

## CI/CD

To automate deployment through Github Actions you need to configure [Github Secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets) inside workflow files.

<Tip>
  The deployment will be triggered on each commit. Committing to the **main**
  branch will trigger a deployment in the **staging** environment, and
  committing to the **production** branch will trigger a deployment in the
  **production** environment.
</Tip>

To check required Secrets you can open workflows in the `.github` folder at root of your project.
To automate deployment to the **production** environment you need to create `DIGITAL_OCEAN_TOKEN` and `KUBE_CONFIG_PRODUCTION` secrets for `api-production.yml` and `web-production.yml` workflows.

`DIGITAL_OCEAN_TOKEN`

![DO Secret](/images/do-secret.png)

`KUBE_CONFIG_PRODUCTION`

![Kubeconfig Secret](/images/kubeconfig-secret.png)

Now commit all changes to GitHub that will trigger deployment.

![CI start](/images/ci-start.png)

Done! Application deployed and can be accessed by provided domain.

![CI finish](/images/ci-finish.png)

![Deployment finish](/images/deployment-finish.png)

![Deployed pods](/images/deployed-pods.png)

<Tip>
  If something went wrong you can check the workflows logs on GitHub and use
  [**kubectl
  logs**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#interacting-with-running-pods),
  [**kubectl
  describe**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#viewing-finding-resources)
  commands.
</Tip>

## Manual deployment

To deploy services in the cluster manually you need to set cluster authorization credentials inside the **config**.
Set `environment` and `namespace` to `production/staging` and set your Personal Access Token in `dockerRegistry.username` and `dockerRegistry.password`.

```javascript deploy/src/config.js
const config = {
  rootDir,

  service: ENV.SERVICE,

  environment: ENV.ENVIRONMENT || "production",

  namespace: ENV.NAMESPACE || "production",

  kubeConfig: ENV.KUBE_CONFIG,

  home: ENV.HOME,

  dockerRegistry: {
    name: "registry.digitalocean.com/oigen43/my-app",
    username: ENV.DOCKER_AUTH_USERNAME || "dop_v1_...",
    password: ENV.DOCKER_AUTH_PASSWORD || "dop_v1_...",

    imageTag: ENV.IMAGE_TAG,
  },
};
```

Run the deployment **script**. It will do the same as the CI deployment, but you run it manually.

```shell deploy/script/src
node index

? What service to deploy? (Use arrow keys)
  api
  web
```
