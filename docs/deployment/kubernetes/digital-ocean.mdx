---
title: "Digital Ocean"
---

It's a step-by-step Ship deployment guide. We will use Digital Ocean Managed [Kubernetes](https://www.digitalocean.com/products/kubernetes), [Container Registry](https://www.digitalocean.com/products/container-registry), [Mongo Atlas](https://www.mongodb.com/), [GitHub Actions](https://github.com/features/actions) for automated deployment, and [CloudFlare](https://www.cloudflare.com/) for DNS and SSL configuration.

You need to create [GitHub](https://github.com/), [CloudFlare](https://www.cloudflare.com/), [Digital Ocean](https://www.digitalocean.com/) and [MongoDB Atlas](https://www.mongodb.com/cloud/atlas/register) accounts and install the next tools on your machine before starting:

* [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl) - CLI tool for accessing Kubernetes cluster;
* [kubectx](https://github.com/ahmetb/kubectx) - CLI tool for easier switching between Kubernetes contexts;
* [helm](https://helm.sh/docs/intro/install) - CLI tool for managing Kubernetes deployments;
* [k8sec](https://github.com/dtan4/k8sec) - CLI tool for managing Kubernetes Secrets easily;

<Accordion title="How to install k8sec on Linux?">
  Download k8sec tar.gz, then do:

  ```
  chmod +x k8sec
  ```
  ```
  sudo cp k8sec /usr/local/bin/
  ```
  ```
  k8sec --help
  ```
</Accordion>

Try the next commands to ensure that everything is installed correctly:

```
kubectl

kubectx

helm

k8sec
```

Also, you need [git](https://git-scm.com/) and [Node.js](https://nodejs.org/en/) if you already haven't.

# Setup project

First, initialize your project. Type `npx create-ship-app@latest` in the terminal then choose **Digital Ocean Managed Kubernetes** deployment type.

![Init project](/images/init-project.png)

You will have next project structure.

```shell
/deploy-guide
  /.github
  /apps
    /api
    /web
  /deploy
  ...
```

Create GitHub private repository and upload source code.

![Private repo](/images/private-repo.png)

```shell
cd my-ship-app
git remote add origin git@github.com:dzinrai/my-ship-app.git
git push -u origin main
```

# Container registry

You need to create [Container Registry](https://www.digitalocean.com/products/container-registry) for storing Docker images. The deployment script will upload images to Container Registry during the build step, and Kubernetes will automatically pull these images from Container Registry to run a new version of service during the deployment step.

Usually `deploy-guide` is the name of organization, and `my-ship-app` is the name of project.

![Container Registry creation](/images/container-registry-creation.png)

After some time, you will get registry endpoint.

![Container Registry creation](/images/container-registry-created.png)

Now you should configure the deployment script to point Container Registry.
Need to update `dockerRegistry.name` value to `registry.digitalocean.com/deploy-guide/my-ship-app`.

```javascript deploy/script/src/config.js
const config = {
  ...
  dockerRegistry: {
    name: "registry.digitalocean.com/deploy-guide/my-ship-app",
    ...
  },
};
```

`registry.digitalocean.com/deploy-guide/my-ship-app` consists of 2 values:

- `registry.digitalocean.com/deploy-guide` - registry endpoint;
- `my-ship-app` - project name;

Docker images for each service are stored in separate repository.
In Digital Ocean repositories are created automatically when something is uploaded by specific paths.
During deployment process script will automatically create paths to repositories in next format:

- [**API**](/api-reference/overview) - registry.digitalocean.com/deploy-guide/my-ship-app-api;
- [**Scheduler**](/scheduler) - registry.digitalocean.com/deploy-guide/my-ship-app-scheduler;
- [**Migrator**](/migrator) - registry.digitalocean.com/deploy-guide/my-ship-app-migrator;
- [**Web**](/web/overview) - registry.digitalocean.com/deploy-guide/my-ship-app-web;

<Tip>
  Images for all environments will be uploaded to the same repository for each
  service.
</Tip>

# Kubernetes cluster

Now let's create [Managed Kubernetes](https://www.digitalocean.com/products/kubernetes) cluster.

<Steps>
  <Step title="Select a region">
    Navigate to the cluster creation page [here](https://cloud.digitalocean.com/kubernetes/clusters/new)<br/>
    <Tip>
      We recommend you to create a cluster in the region where your end-users are located, it will reduce response time to incoming requests to all services.
    </Tip>

    <Tip>
      Also, if your cluster will be located in one region with a Container Registry deployment process will be faster. You can find more information about regions [here](https://docs.digitalocean.com/products/platform/availability-matrix/).
    </Tip>
    <Frame>
      <img src="/images/cluster-region.png" alt="Cluster Region" />
    </Frame>
  </Step>

  <Step title="Set Node pool name">
    Set Node pool name (e.g. `pool-app`) and configure Nodes.
    Digital Ocean recommends creating at least 2 nodes for the production environment. These settings will have an impact on the price of the cluster.

    <Frame>
      <img src="/images/cluster-capacity.png" alt="Cluster Capacity" />
    </Frame>
  </Step>

  <Step title="Configure cluster">
    Now you need to configure node pool in deployment script.
    Need to update `nodePool` value to `pool-app` to match the node pool name we set on the previous step.

    ```javascript deploy/script/src/config.js
    const config = {
      ...
      nodePool: "pool-app",
      dockerRegistry: {
        name: 'registry.digitalocean.com/deploy-guide/my-ship-app',
        ...
      },
    };
    ```
  </Step>

  <Step title="Set cluster name">
    Set cluster name (e.g. `my-ship-app`). A common practice is to use the project name for it.

    <Frame>
      <img src="/images/cluster-name.png" alt="Cluster Name" />
    </Frame>
  </Step>

  <Step title="Review and Create">
    Click on `Create Kubernetes Cluster` button to create a cluster.

    <Frame>
      <img src="/images/do-cluster-creation.png" alt="Cluster Creation" />
    </Frame>
  </Step>
</Steps>

# Personal access token

To upload docker images in Container Registry and pull them after from cluster we need Digital Ocean [Personal Access Token](https://cloud.digitalocean.com/account/api/tokens).
When you created cluster - one with **Read Only** scope was automatically created.

But we need to [generate](https://cloud.digitalocean.com/account/api/tokens/new) a new one with:

- Name (e.g. `my-ship-app-admin-deploy`)
- **Full Access** scope
- No expiration

<Tip>
  You cannot change scope of already generated token.
</Tip>


![Digital Ocean Token](/images/do-token.png)

Now new token can be added to your local kubeconfig's `users`.

```yaml {4}
users:
  - name: do-nyc3-my-ship-app-admin
    user:
      token: dop_v1_... # paste new full access token here
```

<Warning>
  Be very careful with Personal Access Token, if someone steals it he will get access
  to all resources from your Digital Ocean account.
</Warning>

# Accessing cluster from a local machine

<Steps>
  <Step title="Download cluster's kubeconfig">
    Download cluster's kubeconfig, this file includes information for accessing cluster through `kubectl`.

    <Frame>
      <img src="/images/kubeconfig-download.png" alt="Kubeconfig Download" />
    </Frame>

    ```yaml my-ship-app-kubeconfig.yaml
    apiVersion: v1
    clusters:
    - cluster:
        certificate-authority-data: ...
        server: https://...
      name: do-nyc3-my-ship-app
    contexts:
    - context:
        cluster: do-nyc3-my-ship-app
        user: do-nyc3-my-ship-app-admin
      name: do-nyc3-my-ship-app
    current-context: do-nyc3-my-ship-app
    kind: Config
    preferences: {}
    users:
    - name: do-nyc3-my-ship-app-admin
      user:
        token: dop_v1_...
    ```
  </Step>

  <Step title="Add cluster, context and user to kubeconfig">
    <Tip>
      [Kubeconfig](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/) files contain information about several clusters, you have your own on the local machine, it should have been created after `kubectl` installation.
    </Tip>

    You need to add information about the new cluster to your config.
    Find `.kube/config` file on your machine, and add `cluster`, `context` and `user` values from the downloaded config to it.

    ```yaml ~/.kube/config
    apiVersion: v1
    clusters:
    - cluster:
        certificate-authority-data: ...
        server: https://...
      name: some-cluster
    # your new cluster from my-ship-app-kubeconfig.yaml goes here
    - cluster:
        certificate-authority-data: ...
        server: https://...
      name: do-nyc3-my-ship-app
    contexts:
    - context:
        cluster: some-cluster
        user: some-user
      name: some-cluster
    # your new context from my-ship-app-kubeconfig.yaml goes here
    - context:
        cluster: do-nyc3-my-ship-app
        user: do-nyc3-my-ship-app-admin
      name: do-nyc3-my-ship-app
    current-context: some-cluster
    kind: Config
    preferences: {}
    users:
    - name: some-user
      user:
        token: dop_v1_...
    # your new user from my-ship-app-kubeconfig.yaml goes here
    - name: do-nyc3-my-ship-app-admin
      user:
        token: dop_v1_...
    ```
  </Step>

  <Step title="Switch to cluster context">
    Execute kubectx in your terminal and select your cluster from the list.
    ```shell
    kubectx
    ```

    You will see the list of available clusters.

    ```shell
    some-cluster
    do-nyc3-my-ship-app
    ```

    Select your cluster from the list:
    ```shell
    kubectx do-nyc3-my-ship-app
    ```
  </Step>

  <Step title="Verify cluster access">
    Check the installed pods by running:

    ```shell
    kubectl get pods -A
    ```

    You should see a list of system pods in your cluster:

    ```shell
    NAMESPACE     NAME                            READY   STATUS    RESTARTS   AGE
    kube-system   cilium-tb8td                    1/1     Running   0          18m
    kube-system   cilium-x5w8n                    1/1     Running   0          19m
    kube-system   coredns-5679ffb5c8-b7dzj        1/1     Running   0          17m
    kube-system   coredns-5679ffb5c8-d465r        1/1     Running   0          17m
    kube-system   cpc-bridge-proxy-ebpf-2gzfr     1/1     Running   0          17m
    kube-system   cpc-bridge-proxy-ebpf-jknzh     1/1     Running   0          17m
    kube-system   csi-do-node-jcqd2               2/2     Running   0          17m
    kube-system   csi-do-node-rpx6q               2/2     Running   0          17m
    kube-system   do-node-agent-ldhxq             1/1     Running   0          17m
    kube-system   do-node-agent-pdksz             1/1     Running   0          17m
    kube-system   hubble-relay-66f54dcd57-l7xjb   1/1     Running   0          21m
    kube-system   hubble-ui-785bdbc45b-6xd57      2/2     Running   0          18m
    kube-system   konnectivity-agent-h79mt        1/1     Running   0          17m
    kube-system   konnectivity-agent-hvv67        1/1     Running   0          17m
    ```
  </Step>
</Steps>

# Ingress NGINX Controller

[ingress-nginx](https://github.com/kubernetes/ingress-nginx) is an Ingress controller for Kubernetes using [NGINX](https://nginx.org) as a reverse proxy and load balancer.

<Tip>
  Learn more about ingress-nginx functionality in the **[official documentation](https://docs.nginx.com/nginx-ingress-controller/intro/how-nginx-ingress-controller-works/)**.
</Tip>

<Steps>
  <Step title="Navigate to dependencies directory">
    Change to the `deploy/dependencies` directory in your terminal.
  </Step>

  <Step title="Configure Helm Values (Optional)">

    This step is required **only if** you specified a custom node pool name in your Digital Ocean Kubernetes cluster.

    If you did, update the `doks.digitalocean.com/node-pool` value in `values.yaml.gotmpl`:

    ```yaml deploy/dependencies/ingress-nginx/values.yaml.gotmpl {5}
    controller:
      publishService:
        enabled: true
      nodeSelector:
        doks.digitalocean.com/node-pool: pool-app

    rbac:
      create: true

    defaultBackend:
      enabled: false
    ```
  </Step>


  <Step title="Install dependencies">
    Install helm dependencies using helmfile:

    ```bash
    helmfile deps
    ```
  </Step>

  <Step title="Review and apply changes">
    Preview the changes first:

    ```bash
    helmfile diff
    ```

    If the preview looks correct, apply the configuration:

    ```bash
    helmfile apply
    ```
  </Step>
</Steps>

# DNS and SSL

<Steps>
  <Step title="Get Load Balancer Address">
    After deploying ingress-nginx, retrieve the Load Balancer's external ip:

    ```bash
    kubectl get svc ingress-nginx-controller -n ingress-nginx
    ```

    Copy the value from the `EXTERNAL-IP` column.

    ```shell
    NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE
    ingress-nginx-controller             LoadBalancer   10.245.201.160   138.68.124.241   80:30186/TCP,443:32656/TCP   28m
    ```

    <Tip>
      It take some time while **ingress-nginx** will configure everything and
      provide `EXTERNAL-IP`.
    </Tip>
  </Step>

  <Step title="Domain Naming Convention">
    You can follow this recommended naming pattern for different environments:

    | Environment | API Domain           | Web Domain           |
    |-------------|----------------------|----------------------|
    | Production  | api.ship.com         | app.ship.com         |
    | Staging     | api.staging.ship.com | app.staging.ship.com |
  </Step>

  <Step title="Configure DNS in Cloudflare">
    1. First, ensure you have a domain in Cloudflare. You can either:
    - [Register a new domain](https://developers.cloudflare.com/registrar/get-started/register-domain/)
    - [Transfer an existing domain](https://developers.cloudflare.com/registrar/get-started/transfer-domain-to-cloudflare/)

    2. In the Cloudflare DNS tab, create 2 `A` records:
    - One for Web interface
    - One for API endpoint

    Both should point to your Load Balancer's external hostname.

    Enable the **Proxied** option to:
    - Route traffic through Cloudflare
    - Generate SSL certificates automatically

    <Frame>
      <img src="/images/do/cloudflare-api.png" alt="CloudFlare API DNS Configuration" />
    </Frame>

    <br/>

    <Frame>
      <img src="/images/do/cloudflare-web.png" alt="CloudFlare Web DNS Configuration" />
    </Frame>

    <Note>
      Cloudflare's free Universal SSL certificates only cover the apex domain and one subdomain level. For multiple subdomain levels, you'll need an [Advanced Certificate](https://developers.cloudflare.com/ssl/edge-certificates/advanced-certificate-manager/manage-certificates/).
    </Note>
  </Step>

  <Step title="Update Configuration Files">
    Update your domain settings in the appropriate environment configuration files:

    For API service:
    <CodeGroup>
      ```yaml deploy/app/api/production.yaml
      service: api
      port: 3001
      domain: api.my-ship-app.paralect.com
      ```

      ```yaml deploy/app/api/staging.yaml
      service: api
      port: 3001
      domain: api.my-ship-app.staging.paralect.com
      ```
    </CodeGroup>

    For Web service:
    <CodeGroup>
      ```yaml deploy/app/web/production.yaml
      service: web
      port: 3002
      domain: my-ship-app.paralect.com
      ```

      ```yaml deploy/app/web/staging.yaml
      service: web
      port: 3002
      domain: my-ship-app.staging.paralect.com
      ```
    </CodeGroup>
  </Step>
</Steps>

# MongoDB Atlas

[MongoDB Atlas](https://cloud.mongodb.com/) is a fully managed cloud database service that provides automated backups, scaling, and security features. It offers 99.995% availability with global deployment options and seamless integration with AWS infrastructure.

### Cluster Creation

<Steps>
  <Step title="Access MongoDB Atlas">
    Sign in to your [MongoDB Atlas account](https://cloud.mongodb.com/) and create a new project if needed.
  </Step>

  <Step title="Deploy New Cluster">
    Click **Create** to start cluster deployment.

    **Cluster Tier Selection:**
    - **Staging**: `M0` (Free tier) - Suitable for development and testing
    - **Production**: `M10` or higher - Includes automated backups and advanced features

    **Provider & Region:**
    - Select **AWS** as your cloud provider
    - Choose the **same region** as your EKS cluster for optimal performance

    <Frame>
      <img src="/images/mongodb-cloud/deploy-cluster.png" alt="Deploy MongoDB Atlas cluster" />
    </Frame>
  </Step>

  <Step title="Configure Cluster Name">
    Enter a descriptive cluster name (e.g., `ship-production-cluster`, `ship-staging-cluster`)
  </Step>
</Steps>

### Security Configuration

<Steps>
  <Step title="Create Database User">
    Navigate to **Database Access** → **Add New Database User**

    - **Authentication Method**: Password
    - **Username**: Use environment-specific names (e.g., `api-production`, `api-staging`)
    - **Password**: Generate a strong password
    - **Database User Privileges**: **Read and write to any database**

    <Frame>
      <img src="/images/mongodb-cloud/add-database-user.png" alt="Add MongoDB database user" />
    </Frame>

    <Warning>
      **Password Requirements**: Ensure the password starts with a letter and contains only alphanumeric characters and common symbols. Special characters at the beginning can cause URI parsing issues.
    </Warning>
  </Step>

  <Step title="Configure Network Access">
    Navigate to **Network Access** → **Add IP Address**

    - Click **Allow access from anywhere** to allow connections from any IP with valid credentials
    - For production, consider restricting to specific IP ranges for enhanced security

    <Frame>
      <img src="/images/mongodb-cloud/network-access.png" alt="Configure MongoDB network access" />
    </Frame>
  </Step>
</Steps>

### Get Connection String

<Steps>
  <Step title="Access Connection Details">
    Go to your cluster dashboard and click the **Connect** button.

    <Frame>
      <img src="/images/mongodb-cloud/dashboard.png" alt="MongoDB Atlas dashboard" />
    </Frame>
  </Step>

  <Step title="Copy Connection String">
    1. Select **Drivers** in the "Connect your application" section
    2. Choose **Node.js** driver and latest version
    3. Copy the connection string and replace `<db_password>` with your actual password

    <Frame>
      <img src="/images/mongodb-cloud/cluster-connect.png" alt="MongoDB connection string" />
    </Frame>

    **Example Connection String:**
    ```bash
    mongodb+srv://api-production:your-password@cluster0.xxxxx.mongodb.net/?retryWrites=true&w=majority
    ```
  </Step>

  <Step title="Save Connection Details">
    Store the connection string securely - you'll need it for environment configuration later
  </Step>
</Steps>

<Tip>
  Before deploying to production, configure [automated backups](https://www.mongodb.com/docs/atlas/backup-restore-cluster/) in the Atlas console to ensure data recovery capabilities.
</Tip>

# Environment variables

Kubernetes applications require proper environment variable configuration for both API and Web components. This section covers how to set up and manage environment variables securely using Kubernetes secrets and configuration files.

### API Environment Variables

For the API deployment, you need to set up environment variables using Kubernetes secrets to securely manage sensitive configuration data.

<Info>
  **Secrets** in Kubernetes are used to store sensitive information, such as passwords, API tokens, and keys.
  They are encoded in Base64 format to provide a level of security.
  These can be mounted into containers as data volumes or used as environment variables.
</Info>

Before deploying the app, make sure all necessary variables from the API config are exist. Here are the minimal set of required variables:

| Name            | Description                | Example value                                      |
|-----------------|----------------------------|----------------------------------------------------|
| `APP_ENV`       | Application environment    | `production`                                       |
| `MONGO_URI`     | Database connection string | `mongodb://<username>:<password>@ship.mongodb.net` |
| `MONGO_DB_NAME` | Database name              | `api-production`                                   |
| `API_URL`       | API domain URL             | `https://api.my-ship-app.paralect.com`             |
| `WEB_URL`       | Web app domain URL         | `https://my-ship-app.paralect.com`                 |
| `JWT_SECRET`    | JWT signing key            | `Vz2Ol8HKBO0/38i1IBm2uJ7JnVabWGm0RiRVY5w1sNY=`     |

#### Environment Variable Details

<Accordion title="APP_ENV">
  Specifies the application environment (development, staging, production). This controls logging levels, debugging features, error reporting, and other environment-specific behaviors. The API uses this to determine which configuration settings to load.
</Accordion>

<Accordion title="MONGO_URI">
  MongoDB connection string including authentication credentials and cluster information. This is the primary database connection for the API. Format: `mongodb+srv://username:password@cluster.mongodb.net`. Each environment should use a separate database cluster or at minimum separate credentials.
</Accordion>

<Accordion title="MONGO_DB_NAME">
  Name of the MongoDB database to use for this environment. Each environment (development, staging, production) should have its own database to prevent data conflicts and ensure proper isolation.
</Accordion>

<Accordion title="API_URL">
  The fully qualified domain name where the API will be accessible. This must be a valid HTTPS URL and should match your Kubernetes ingress configuration. Used for CORS settings and internal service communication.
</Accordion>

<Accordion title="WEB_URL">
  The fully qualified domain name where the web application will be accessible. Used for CORS configuration, redirect URLs, email templates, and social sharing metadata. Must be a valid HTTPS URL.
</Accordion>

<Accordion title="JWT_SECRET">
  Secret key used for signing and verifying JSON Web Tokens. Should be a long, random string (minimum 32 characters). Can be generated using `openssl rand -base64 32`. Keep this secret secure and rotate it regularly.
</Accordion>

#### Setting up Kubernetes Secrets

<Steps>
  <Step title="Create namespaces and secret objects">
    Create Kubernetes namespaces and secret objects for staging and production environments:

    ```bash
    kubectl create namespace staging
    kubectl create secret generic api-staging-secret -n staging
    kubectl create namespace production
    kubectl create secret generic api-production-secret -n production
    ```
  </Step>

  <Step title="Initialize secret storage">
    First, create an `APP_ENV` variable to initialize secret storage for k8sec:

    <CodeGroup>
      ```bash production
      k8sec set api-production-secret APP_ENV=production -n production
      ```

      ```bash staging
      k8sec set api-staging-secret APP_ENV=staging -n staging
      ```
    </CodeGroup>
  </Step>

  <Step title="Verify secret creation">
    Run the following command to check the created secret:

    <CodeGroup>
      ```bash production
      k8sec list api-production-secret -n production
      ```

      ```bash staging
      k8sec list api-staging-secret -n staging
      ```
    </CodeGroup>
  </Step>

  <Step title="Prepare environment file">
    Create a `.env.production` file with all required variables:

    <CodeGroup>
      ```bash .env.production
      APP_ENV=production
      MONGO_URI=mongodb://username:password@ship.mongodb.net
      MONGO_DB_NAME=api-production
      API_URL=https://api.my-ship-app.paralect.com
      WEB_URL=https://my-ship-app.paralect.com
      JWT_SECRET=Vz2Ol8HKBO0/38i1IBm2uJ7JnVabWGm0RiRVY5w1sNY=
      ```

      ```bash .env.staging
      APP_ENV=staging
      MONGO_URI=mongodb://username:password@ship.mongodb.net
      MONGO_DB_NAME=api-staging
      API_URL=https://api.my-ship-app.staging.paralect.com
      WEB_URL=https://my-ship-app.staging.paralect.com
      JWT_SECRET=Ol2Ol8HKBO0/38i1IBm2uJ7Jn3oabWGm0RiRVY5w1sNY=
      ```
    </CodeGroup>


    <Warning>
      Replace all example values with your actual configuration. Never use production secrets in documentation or version control.
    </Warning>
  </Step>

  <Step title="Import secrets to Kubernetes">
    Import secrets from the .env file to Kubernetes secret using k8sec:

    <CodeGroup>
      ```bash production
      k8sec load -f .env.production api-production-secret -n production
      ```

      ```bash staging
      k8sec load -f .env.staging api-staging-secret -n staging
      ```
    </CodeGroup>
  </Step>
</Steps>

<Warning>
  After updating environment variables, you must initiate a new deployment for changes to take effect.
  Kubernetes pods cache variable values during startup, requiring a pod restart or rolling update to apply changes.
</Warning>

### Web Environment Variables

The web application uses Next.js environment variables that are embedded at build time and made available in the browser. Unlike API secrets, these variables are stored directly in the GitHub repository.

<Info>
  **Why Web Environment Variables Are Safe in Git**: Web environment variables (prefixed with `NEXT_PUBLIC_`) contain only public configuration like URLs and API endpoints. They don't include sensitive data like passwords or API keys, making them safe to store in version control. These values are already exposed to users in the browser, so repository storage doesn't create additional security risks.
</Info>

<Warning>
  **Security Notice**: Never store sensitive information (passwords, API keys, secrets) in web environment files as they will be accessible on the client side. Only use public configuration values that are safe to expose to end users.
</Warning>

#### Configuration Files

Web environment variables are stored in separate files for each deployment environment:

<CodeGroup>
  ```bash apps/web/.env.production
  NEXT_PUBLIC_API_URL=https://api.my-ship-app.paralect.com
  NEXT_PUBLIC_WS_URL=https://api.my-ship-app.paralect.com
  NEXT_PUBLIC_WEB_URL=https://my-ship-app.paralect.com
  ```

  ```bash apps/web/.env.staging
  NEXT_PUBLIC_API_URL=https://api.my-ship-app.staging.paralect.com
  NEXT_PUBLIC_WS_URL=https://api.my-ship-app.staging.paralect.com
  NEXT_PUBLIC_WEB_URL=https://my-ship-app.staging.paralect.com
  ```
</CodeGroup>

#### Environment Variables Reference

| Variable              | Description                           | Example                                |
|-----------------------|---------------------------------------|----------------------------------------|
| `NEXT_PUBLIC_API_URL` | Base URL for API requests             | `https://api.my-ship-app.paralect.com` |
| `NEXT_PUBLIC_WS_URL`  | WebSocket server URL for real-time    | `https://api.my-ship-app.paralect.com` |
| `NEXT_PUBLIC_WEB_URL` | App's own URL for redirects/metadata  | `https://my-ship-app.paralect.com`     |

<Tip>
  **Best Practice**: Keep web environment files in your repository and ensure all values are non-sensitive. If you need to reference sensitive data from the frontend, create a secure API endpoint that returns the necessary information after proper authentication.
</Tip>


# Setting up GitHub Actions CI/CD

To automate deployment through Github Actions you need to configure [Github Secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets) inside workflow files.

<Tip>
  The deployment will be triggered on each commit. Committing to the **main**
  branch will trigger a deployment in the **staging** environment, and
  committing to the **production** branch will trigger a deployment in the
  **production** environment.
</Tip>

To check required Secrets you can open workflows in the `.github` folder at root of your project.
To automate deployment to the **production** environment you need `DIGITAL_OCEAN_TOKEN` and `KUBE_CONFIG_PRODUCTION` secrets for `api-production.yml` and `web-production.yml` workflows.

`DIGITAL_OCEAN_TOKEN`

Personal access token from [Personal access token](#personal-access-token) section.

![DO Secret](/images/do-secret.png)

`KUBE_CONFIG_PRODUCTION`

Kubeconfig file from [Accessing cluster from a local machine](#accessing-cluster-from-a-local-machine) section.

![Kubeconfig Secret](/images/kubeconfig-secret.png)

Now commit all changes to GitHub that will trigger deployment.

![CI start](/images/ci-start.png)

Done! Application deployed and can be accessed by provided domain.

![CI finish](/images/ci-finish.png)

![Deployment finish](/images/deployment-finish.png)

![Deployed pods](/images/deployed-pods.png)

<Tip>
  If something went wrong you can check the workflows logs on GitHub and use
  [**kubectl
  logs**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#interacting-with-running-pods),
  [**kubectl
  describe**](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#viewing-finding-resources)
  commands.
</Tip>

# Manual deployment

To deploy services in the cluster manually you need to set cluster authorization credentials inside the **config**.
Set `environment` and `namespace` to `production/staging` and set your Personal Access Token in `dockerRegistry.username` and `dockerRegistry.password`.

```javascript deploy/src/config.js
const config = {
  rootDir,

  service: ENV.SERVICE,

  environment: ENV.ENVIRONMENT || "production",

  namespace: ENV.NAMESPACE || "production",

  kubeConfig: ENV.KUBE_CONFIG,

  home: ENV.HOME,

  dockerRegistry: {
    name: "registry.digitalocean.com/oigen43/my-app",
    username: ENV.DOCKER_AUTH_USERNAME || "dop_v1_...",
    password: ENV.DOCKER_AUTH_PASSWORD || "dop_v1_...",

    imageTag: ENV.IMAGE_TAG,
  },
};
```

Run the deployment **script**. It will do the same as the CI deployment, but you run it manually.

```shell deploy/script/src
node index

? What service to deploy? (Use arrow keys)
  api
  web
```
