---
title: "Testing"
---

## Overview

Tests in Ship applications is **optional by default**. The template comes without testing dependencies to keep it lightweight and focused on rapid development. However, when your project grows in complexity or requires high reliability, testing becomes essential.

<CardGroup cols={2}>
  <Card title="When to Add Testing" icon="shield-check">
    - Complex and confusing business rules
    - Critical calculations/algorithms
    - Core flows that affect other features
    - Logic reused across the applications
    - Areas with recurring hard bugs
  </Card>
  <Card title="When to Skip Testing" icon="ban">
    - Simple CRUD operations
    - Prototype/MVP development
    - Short-term projects
    - Basic UI components
    - Static content pages
  </Card>
</CardGroup>

## Installation and Setup

### Installing Dependencies

Add the necessary testing packages to your project:

```shell
pnpm add -D --filter=api \
     jest \
     @types/jest \
     ts-jest \
     @shelf/jest-mongodb \
     mongodb-memory-server \
     supertest
```

### Jest Configuration

Create jest.config.js in the root of apps/api:

```javascript apps/api/jest.config.js
/** @type {import('jest').Config} */
const config = {
  preset: '@shelf/jest-mongodb',
  verbose: true,
  testEnvironment: 'node',
  testMatch: ['**/?(*.)+(spec.ts)'],
  transform: {
    '^.+\\.(ts)$': 'ts-jest',
  },
  watchPathIgnorePatterns: ['globalConfig'],
  roots: ['<rootDir>'],
  modulePaths: ['src'],
  moduleDirectories: ['node_modules'],
  testTimeout: 10000,
};

export default config;
```

### package.json scripts

Add test scripts to your `apps/api/package.json`:

```json apps/api/package.json
{
  "scripts": {
    "test": "jest --runInBand -c ./jest.config.js --collectCoverage false",
    "test:watch": "jest --watch -c ./jest.config.js",
    "test:coverage": "jest --coverage -c ./jest.config.js"
  }
}
```

### Test Structure

Tests should be placed next to the code they are testing inside a `tests/` folder. Use `*.spec.ts` suffixes and standardize by unit type:

- `.action.spec.ts` — for action handler + validator (HTTP via supertest)
- `.service.spec.ts` — for data/service layer
- `.validator.spec.ts` — for standalone schema/validators

#### API resource example

```text
apps/api/src/resources/user/
├── actions/
│   ├── create.ts
│   └── tests/
│       └── create.action.spec.ts
├── user.service.ts
├── user.routes.ts
└── tests/
    ├── user.service.spec.ts
    └── factories/
        └── user.factory.ts
```

#### Utilities 

Colocate tests for utility modules. Keep them small and pure (no DB).

Create `tests/` folder inside `utils`

```text
apps/api/src/utils/
├── cookie.util.ts
├── promise.util.ts
├── security.util.ts
└── tests/
    ├── cookie.util.spec.ts
    ├── promise.util.spec.ts
    └── security.util.spec.ts
```


## Testing Examples

### Service Integration Test Example

```typescript user.service.spec.ts
import { Database, generateId } from '@paralect/node-mongo';

import { DATABASE_DOCUMENTS } from 'app-constants';
import { userSchema } from 'schemas';
import { User } from 'types';

const database = new Database(process.env.MONGO_URL as string);

const userService = database.createService<User>(DATABASE_DOCUMENTS.USERS, {
  schemaValidator: (obj) => userSchema.parseAsync(obj),
});

describe('User service', () => {
  beforeAll(async () => {
    await database.connect();
  });

  beforeEach(async () => {
    await userService.deleteMany({});
  });

  it('should create user', async () => {
    const mockUser = {
      _id: generateId(),
      firstName: 'John',
      lastName: 'Doe',
      email: 'john.doe@example.com',
      isEmailVerified: false,
    };

    await userService.insertOne(mockUser);

    const insertedUser = await userService.findOne({ _id: mockUser._id });

    expect(insertedUser).not.toBeNull();
    expect(insertedUser?.email).toBe(mockUser.email);
  });

  it('should update user', async () => {
    const user = await userService.insertOne({
      _id: generateId(),
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@example.com',
      isEmailVerified: false,
    });

    await userService.updateOne(
      { _id: user._id },
      { $set: { isEmailVerified: true } }
    );

    const updatedUser = await userService.findOne({ _id: user._id });
    expect(updatedUser?.isEmailVerified).toBe(true);
  });

  afterAll(async () => {
    await database.close();
  });
});
```

### API Action Test Example

Test your API endpoints:

```typescript create.action.spec.ts
import request from 'supertest';
import { Database } from '@paralect/node-mongo';

import app from 'app';
import { DATABASE_DOCUMENTS } from 'app-constants';

describe('POST /api/users', () => {
  beforeEach(async () => {
    // Clean test data
  });

  it('should create user with valid data', async () => {
    const userData = {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john.doe@example.com',
    };

    const response = await request(app.callback())
      .post('/api/users')
      .send(userData)
      .expect(201);

    expect(response.body).toMatchObject({
      firstName: userData.firstName,
      lastName: userData.lastName,
      email: userData.email,
    });
  });

  it('should return validation error for invalid email', async () => {
    const userData = {
      firstName: 'John',
      lastName: 'Doe',
      email: 'invalid-email',
    };

    await request(app.callback())
      .post('/api/users')
      .send(userData)
      .expect(400);
  });
});
```

### Testing Utilities
``` typescript security.util.spec.ts
import { securityUtil } from 'utils';

describe('Security utils', () => {
  describe('generateSecureToken', () => {
    it('should generate token of specified length', () => {
      const token = securityUtil.generateSecureToken(32);
      
      expect(token).toHaveLength(32);
      expect(typeof token).toBe('string');
    });
  });

  describe('hashPassword', () => {
    it('should hash password correctly', async () => {
      const password = 'test-password-123';
      const hash = await securityUtil.hashPassword(password);
      
      expect(hash).not.toBe(password);
      
      const isValid = await securityUtil.compareTextWithHash(password, hash);
      expect(isValid).toBe(true);
    });
  });
});
```

## Best Practices

### Test Isolation

Each test should be isolated from the others.

Use `beforeEach` to clean the database before each test.

```typescript
describe('User service', () => {
  beforeEach(async () => {
    // Clean database before each test
    await userService.deleteMany({});
  });
});
```

### Test Naming

Use descriptive test names that explain the expected behavior:

```typescript
// Good
it('should return user data when valid ID is provided', () => {});

// Bad
it('should work', () => {});
```


### Mock External Services

Mock external API calls and services:

```typescript
jest.mock('@aws-sdk/client-s3', () => ({
  S3Client: jest.fn(),
  PutObjectCommand: jest.fn(),
}));
```
